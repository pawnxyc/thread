1.当一个线程被new出来只是一个实列对象，必须调用start方法，才会被加到group中，start其实也会去调用run方法
2.java的程序启动时，jvm会有一个main线程去执行代码，并且有若干个守护线程。
3.当你调用一个Thread的start方法时，当前至少有两个线程，一个是调用你start方法的线程，一个是当前thread变成
一个线程。
4.线程的生命周期：new runnable running broke termite
5.Thread的构造方法Thread(Runnable target, String name),如果没有传第一个参数，则不执行任何代码。
6.如果在创建线程时，未指定ThreadGroup，则默认与父线程在同一个组中。
7.Thread(group,target,name,stacksize),指定线程的内存大小（1024*1024=1m）。
8.Thread group可以统一管理一堆线程，停止，等待。
9.join().->wait for this thread died,then go run others.
10.使用wait,notify,notifyall时需要先对调用的对象上锁，notify只是让一个线程重新进入竞争锁的queue中，不是马上执行
11.基于注解型的事务管理是通过spring的aop方式实现的。需要加@transactional注解。默认是一旦抛出Exception.class
就回滚所有的增删改操作，可以配置参数。底层实现其实是利用了线程的Threadlocal这个变量的每个线程隔离性。
来实现一个方法中所有的connection是同一个。
12.ThreadLocal内部的set方法是让ThreadLocal作为对象，让object为值设置到当前线程的ThreadLocalMap中。
所以是当前线程的私有变量，TL内部有一个entry，它的key是一个弱引用指向的TL，防止内存泄漏。但是不用TL时，
还是最后remove一下。
13.volatile有两个特性
内存可见性：底层实现是cacheline 高速缓存行，每次读64个字节到L1，l2中，然后改变并且刷新到内存中，如果其他线程
需要使用此变量。
禁止指令重排。jvm的实现是内存屏障。前面加，后面加，让中间的这个变量的操作，不会发生指令重排。
14.AQS：是java并发包下面的一个抽象类。中文抽象同步队列。在jdk的层面实现了一个同步队列，让线程在同步队列中挂起
一旦锁释放，就通知队列中的节点去竞争，底层通过cas去看state的状态，如果为0则获取锁。并且设置当前线程占有。
公平锁每次竞争不会去判断state。而是直接去执行acquire（1），来尝试获取。没有给刚释放锁的线程机会。